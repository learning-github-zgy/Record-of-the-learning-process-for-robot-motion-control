传统的机械臂控制是 IK，机器人是 MPC 和零力矩点控制；

目前有很多利用强化学习、模仿学习进、扩散模型进行仿真再 sim to real 进行控制。

这个在读博士总结的很全面，因为他也是从传统控制一步步走到现在强化学习的路上

[四/双足机器人的运动规划与控制：一个在读PhD的阶段性回顾 - 知乎](https://zhuanlan.zhihu.com/p/658133852)

 

<h1 id="fRWLz">八股</h1>
<h2 id="GyyjG">计算机自学指南</h2>
[CS自学指南](https://csdiy.wiki/)北大计算机同学写的计算机学习路线以及优质的课程内容，方便进行学习。

<h2 id="Ib0qW">磨菇书 EasyRL</h2>
[蘑菇书EasyRL](https://datawhalechina.github.io/easy-rl/#/)是主要是基于李宏毅的深度强化学习部分的解读，里面不仅有李宏毅讲课时关键概念的解释，对应的每一章还有习题和面试官的问题来进行巩固，很详细。

- [ ] 绪论
- [ ] 马尔可夫决策过程
- [ ] 表格型方法
- [x] 策略梯度
- [x] 近端策略优化
- [ ] 深度 Q 网络
- [ ] 深度 Q 网络进阶技巧
- [ ] 针对连续动作的深度 Q 网络
- [ ] 演员评论家算法
- [ ] 稀疏奖励
- [x] 模仿学习
- [ ] 深度确定性策略梯度
- [ ] Alphastar 论文解读



<h2 id="dIof3">角色动画</h2>
games105 课程：[Lecture03 Character Kinematics: Forward and Inverse Kinematics_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1GG4y1p7fF?p=3&vd_source=32aee7e160efdea3b1422dda7cc2726a)

里面有很多 IK 和重定向的基础知识，常看常新

评论总结的 PDF：[foocker/CharacterAnimation](https://github.com/foocker/CharacterAnimation)

[CharacterAnimation.pdf](https://www.yuque.com/attachments/yuque/0/2024/pdf/39264174/1718609713267-62d61d0b-5216-47a9-bbfb-403a6a33edac.pdf)



<h2 id="R9L2S">强化学习和最优控制</h2>
[https://web.mit.edu/dimitrib/www/RLbook.html](https://web.mit.edu/dimitrib/www/RLbook.html)

![](https://cdn.nlark.com/yuque/0/2024/jpeg/39264174/1725853375634-b343abcc-c9c3-4e4c-b25f-37f05c20c069.jpeg)

<h2 id="q91j3">强化学习数学原理</h2>
[【强化学习的数学原理】课程：从零开始到透彻理解（完结）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1sd4y167NS/?spm_id_from=333.999.0.0&vd_source=288648f5b920459d12ebbcfd2da00a19)

github 地址：[MathFoundationRL/Book-Mathematical-Foundation-of-Reinforcement-Learning: This is the homepage of a new book entitled "Mathematical Foundations of Reinforcement Learning."](https://github.com/MathFoundationRL/Book-Mathematical-Foundation-of-Reinforcement-Learning)

里面有 pdf 版本介绍各个章节，常看这个可以了解强化学习的数学公式！

<h2 id="LShtD">OpenAI 的 Spinning Up</h2>
[Welcome to Spinning Up in Deep RL! — Spinning Up documentation](https://spinningup.openai.com/en/latest/index.html)

<h3 id="wfNi8">强化学习的关键概念</h3>
在 RL 中策略通常决定在给定状态下的应该采取什么动作，策略的输出可以是确定的动作，策略可以输出一个概率分布，即均值和标准差，这里的概率分布式多元高斯分布，每个动作都有独立的均值和标准差，这里的标准差是对数标准差，因为 log 函数的范围是正负无穷，标准差是非负，刚好可以讲标准差映射到实数范围。当智能体采取动作时，需要从输出的分布中进行采样，采样的公式为：![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720162729069-8b095f6e-8d2b-470e-8971-363fcff53259.png)其中 z 为噪声，为了增加鲁棒性以及探索更多的可能性，输出的标准差与球形高斯噪声相乘。

在策略输出概率分布之后，对数似然可以计算当前的动作与期望的动作之间的差异，其中第一项表示当前的动作与输出概率分布之间的差异。通过调整对数似然估计来调整其中的参数，使策略更新的时候朝向提高采样动作概率的方向进行，从而增加高回报动作的概率，这里的采样动作是具有高 reward 的样本空间。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720163248181-4383e526-78d8-425d-ab26-778f6b0a7d67.png)

轨迹是一系列状态和动作，通常还被称为 episode 和 rollouts。

价值函数和动作价值函数之间有一定的关联：第一个公式：价值函数等于动作价值函数的期望，因为在当前状态下采取所有的动作计算的汇报再求期望就是等于在该状态下的值函数；同理第二个公式：最优值函数等于最大的最优动作值函数，因为最优的动作值函数等于在当前状态下采取动作的最大汇报，那么我取最大值就是当前状态下的最大汇报了，也就是最优值函数。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720167144092-02c813c7-c7e8-4767-b9e1-83683ed6808a.png)

贝尔曼方程思想：出发点的 reward 就是一开始的奖励加上接下来达到点的奖励。

可以看到值函数的贝尔曼方程和动作价值函数的贝尔曼方程之间的关系，再结合值函数和动作价值函数就可以很清楚的看出动作价值函数的第二项就是在状态 s'的值函数。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720167869135-90e0c8ed-b332-4cd7-8c3e-c4de744c78bf.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720167877890-29ea051a-f75e-47d7-9a02-da838ea3ea44.png)

Bellman backup 是贝尔曼方程的右侧，就当前的奖励家还是那个下一个奖励。

优势函数：描述选择该动作比另一个动作好多少![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720168496822-81e799b5-212c-478a-9349-deedca5f3767.png)

马尔可夫决策过程：状态转移只取决于当前的状态和动作，与之前的状态和动作无关。

<h3 id="wuL8c">强化学习算法的分类</h3>
![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720168563594-02bf24f7-1e08-46ae-9e56-e0d6ef4b3ec5.png)

有无模型的区别在于是否拥有环境模型，一般来说环境模型很难获取，或者从经验中学习到的环境模型有偏差，基于模型学习到的策略部署到实际环境中会有问题，因此目前流行 model free 的方式。

在 model free 中强化学习训练代理的方法有策略优化和 Q learning，其中策略优化每次在更新时使用的数据是根据最新的策略收集的数据，策略优化通常是是学习值函数。

Q-learning 通常是学习动作值函数，使用基于贝尔曼方程的目标函数，在优化时使用的数据是训练期间获得的数据，因此不依赖于最新的策略。

策略优化稳定可靠，并且可以直接优化想要优化的目标。而 Q learning 是通过训练贝尔曼方程来间接优化策略，不太稳定，但是样本的使用效率非常高。

还有就是介于这两种方法之间的算法，能够平衡两者的优劣，如 SAC 使用随机策略、熵正则化等。

<h3 id="NWL9p">策略优化</h3>
+ 策略优化中的损失函数是在固定数据分布上定义的，该数据分布与要优化的参数无关；
+ 损失函数通常是评估我们关心的性能指标，在机器学习中如果损失函数下降，就意味着策略的效果很好，但是在策略梯度中，只有平均的回报才意味着策略的表现是否良好，损失函数不一定。

轨迹的概率：![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256565493-b9dd0e37-6a77-4e26-b736-0b6840fb8995.png)

对数求导技巧：![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256594038-782e5134-f980-4090-80da-ba9c3625ed87.png)

轨迹的对数概率：![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256620966-c4b598c5-7d0d-4605-9506-0d4c1ce2d105.png)

环境函数的梯度，因为环境和策略的概率分布参数无关，所以求导为 0：

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256692852-d2a7cfff-bcaa-48fe-be0c-3c8d7b8f7925.png)

所以策略梯度可以写成：

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1720256731740-37b32b17-366b-49d5-b7cb-3606953f8f02.svg)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256780165-275169b8-865a-4b1b-903c-d56f2987ed7b.png)

最简单的策略梯度的 pythoch 实现：[spinningup/spinup/examples/pytorch/pg_math/1_simple_pg.py at master · openai/spinningup](https://github.com/openai/spinningup/blob/master/spinup/examples/pytorch/pg_math/1_simple_pg.py)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256906508-b1d0fdae-0f06-49f4-93ad-4da27e3bf1e0.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256950801-7101b5b9-813a-487f-9b3b-66a2ee7801d8.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256968623-579f2108-f7da-400a-a613-eeb269247fe2.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720256989953-692215ec-f961-439c-9e56-3549f99e52f0.png)

最常见的基线函数是价值函数，表示智能体从该状态开始获得的平均回报，可以减少策略梯度样本的估计方差，导致更稳定的策略学习，保持了梯度估计的无偏性。并且如果智能体在某个状态下获得了较高的回报，但是这个回报正好是该状态下的预期回报，那么这一个状态对梯度的贡献相比于之前不使用价值函数来说会减少。

对于策略梯度来说，**策略梯度**具有以下的一般形式：<font style="background:#C0DDFC;color:#00346B">策略梯度更新公式</font>  
![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257454162-72367211-12b3-4c12-9521-f5b49f5f5fd8.png)其中最后的![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257471324-e40d1678-1d39-445d-8aec-a8ec19f6afd8.png)可以是以下任意一个函数：![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257487073-8435de42-bc21-4e77-95c1-08284004c9a4.png)![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257492408-bd86c29f-19e6-4278-bdff-2e24fe8ad32b.png)![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257497058-3f4092f1-ea95-44ea-be42-f2ac7cc901f7.png)。

在策略动作价值函数中，![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257534293-3133ed47-7c14-4ecb-a5c6-d11d4da2233e.png)可以选择动作价值函数或者优势函数。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257699804-be066d61-6ad8-47e2-badc-075cfc85b746.png)![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1720257704816-5667eb25-bd5b-4c95-9fb1-834e09d89935.png)

[[1506.02438] High-Dimensional Continuous Control Using Generalized Advantage Estimation](https://arxiv.org/abs/1506.02438)论文详细描述了广泛使用的策略优化算法中近似优势函数的方法。

<h3 id="cJISq">PPO</h3>
基础知识：

动作值函数![image](https://cdn.nlark.com/yuque/__latex/2251ac180583f82c3a1f28c20d677d8c.svg)，值函数![image](https://cdn.nlark.com/yuque/__latex/283b1b0d0929bc6fe1f092901d366e1a.svg)

即使两个分布的期望相同，但是随机变量的分布也不一定一样，如下式所示：

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723089309212-01957b3b-5ffc-4800-9560-b5a5b85e5306.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723099307474-68b5e930-3172-43e9-8834-1c28dd7a1624.png)

PPO 中求导常用的公式：

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723089349459-f72932ca-4965-481e-be64-ec744f427660.png)

---

PPO 是策略梯度更新得一种算法，所以解决得问题是策略梯度更新中出现的问题，策略梯度更新的公式如[3策略优化](#NWL9p)中描述的一样，具有一个一般性的公式，在 PPO 中主要是将![image](https://cdn.nlark.com/yuque/__latex/212d2f473ab5a2a1d1d5efc36fd92023.svg)设计为优势函数，其中优势函数具体是描述当前选择这个动作的相对好坏，是将当前动作值函数减去当前状态平均的值函数。

之前的![image](https://cdn.nlark.com/yuque/__latex/212d2f473ab5a2a1d1d5efc36fd92023.svg)是设为奖励函数，只不过这里的奖励函数是一个 episode 交互完成之后的奖励函数之和，而不是每一步操作对应的奖励，所以就会导致即使某个 action 是不对的，但是整个 episode 中有的 action 是正确的，最后的奖励函数仍然是对的，所以为了避免这种情况，我们不应该让之前的行为影响现在的 action，所以奖励函数变为了 reward to go，即奖励变为了从当前的 action 交互之后的所有奖励之和，之前的奖励不会累加到当前的 action 奖励上面，这一点在 spinning up 中的第三点[https://spinningup.openai.com/en/latest/spinningup/rl_intro3.html#don-t-let-the-past-distract-you](https://spinningup.openai.com/en/latest/spinningup/rl_intro3.html#don-t-let-the-past-distract-you)中有官方的阐述。并且为了使奖励函数更关注当前的 action，还在奖励函数中加入了权重因子![image](https://cdn.nlark.com/yuque/__latex/6818f55fc4bda4345791ed3fd47fab36.svg)，这样 action 乘的奖励函数将会更加关注当前动作产生的影响，很多步之后的动作产生的影响对当前的 action 应该比较小。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723089055058-9f550adf-8134-491e-88e5-8a83e6960e28.png)

即使变为 reward to go 之后仍然存在一个问题，就是奖励都是正值，这就导致了如果由于某些原因没有采样到一个动作，那么这个动作的概率就一定会降低，因为奖励都是正值，但是那个没有采样到的动作不一样是不好的，所以为了解决这个问题将![image](https://cdn.nlark.com/yuque/__latex/212d2f473ab5a2a1d1d5efc36fd92023.svg)中加入了基线函数，这个基线函数可以随便取，而在优势函数中，**基线函数是当前状态的平均奖励**。

因此 PPO 中策略梯度更新的公式为：

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723087604762-f1b48136-07b1-48d7-81a7-a843f11705ef.png)

PPO 原本是在线的，即训练的策略和与环境交互的策略是一个策略，但是这种方式训练的效率很慢，时间全用在和环境交互上面了，同时会浪费大量的数据。因此就提出了**重要性采样**：即与环境交互的是一个策略，训练的是另一个策略，这两个策略的分布是不一样的，为了能够训练出好的控制策略，而不是与环境交互的策略，在原先的基础之上乘了个权重，圈起来的部分就是，这样就可以从原先的 p 分布中采样变为从任意的 q 分布中采样来训练策略。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723087916521-ae676031-d94f-48a1-9a72-c0701c208e42.png)

由下图可以看出，这两个分布是不一样的，但是只要采样的数量比较多，通过这个权重系数还是可以近似为原先 p 的分布。这样 PPO 就从在线策略变为了离线策略，即 **off-policy**.

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723088027621-640c7461-8548-4a43-b0d6-283a4cd55b78.png)

即使 p 分布和 q 分布可以不一致，但是这两个分布不可以差的很多，所以为了限制这两个分布的差异程度，提出了 TRPO，其中 TRPO 是将这两个分布的 **KL 散度**作为硬约束加到到目标函数中，如下图所示：KL 散度是作为约束条件在目标函数之外的。这很难去求解。

> [机器学习_KL散度详解（全网最详细）_kl散度计算公式-CSDN博客](https://blog.csdn.net/Rocky6688/article/details/103470437)
>

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723088296388-8d579c86-c908-4593-9fff-c6ffa84b7eff.png)

所以 PPO 在 TRPO 的基础之上，将 KL 散度作为软约束加到了目标函数之内，如下图所示，并且 KL 散度的权重![image](https://cdn.nlark.com/yuque/__latex/6100158802e722a88c15efc101fc275b.svg)可以跟据计算的效果进行更新，即如果优化之后这两个分布差距很小，那么就减小权重系数，提供更多的探索性，反之如果这两个分布差异很大，那么就增大这个权重系数。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723088397841-e9e61737-74f8-4b8d-aa67-9ec4e4cfb9cb.png)

但是 PPO 还有一个更方便的变体，这也是 OpenAI 官方使用的 PPO，就是不需要计算 KL 散度，因为计算 KL 散度实际上也很麻烦，需要将通过目标函数求出的 p 分布和原先的 q 分布进行采样，然后才能计算 KL 散度。不需要 KL 散度之后为了限制策略更新的幅度，加入了**剪裁函数**，如下图所示，即

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723088726085-a31cf3ff-4022-4027-8b0c-ed6f04d77437.png)

即当优势函数大于 0 的时候，为了限制 p 分布和 q 分布之间太接近，设计了上限；当优势函数小于 0 的时候，为了限制 p 分布和 q 分布之间差异过大，设计了下限，其中![image](https://cdn.nlark.com/yuque/__latex/c57c5f0e31d8960d9406bb149fced9e0.svg)一般为 0.2。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1723088789433-f1e9a028-ef33-4dcc-a6c1-b6c58244eb5b.png)

<h4 id="dB8vU">ppo 的 trick</h4>
首先 PPO 中 clip 是 cpi 在![image](https://cdn.nlark.com/yuque/__latex/ed5a4aa5e092e303a69c608582c70db9.svg)附近的一阶导，并且没有将策略之间的差异（KL 散度）作为硬约束或者惩罚加入到目标函数中，因为这样会带来计算目标函数时的复杂。

优势函数就是采取的广义优势函数，当前状态的 reward to go 奖励减去当前状态的平均奖励。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1728355276077-c5b737e9-abef-43b7-a763-464a2e3cf1e7.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1728355266634-9e2d3a8c-6957-413e-a23a-d8dc5e6ec5f7.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1728355885975-2d496844-661e-4ba2-a7e9-919880068e49.png)

<h1 id="hIhtt">强化学习的网络架构</h1>
<h2 id="qmTvr">跟李沐动手学深度学习</h2>
<h3 id="eDZ1J">符号</h3>
不同的 X 代表不同的含义，看清楚！

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241657456-718a5e51-a09f-4183-a1fb-7467f1bdc58c.png)![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241669809-86aaf0f3-36b3-41ec-8ab6-49f1910895f5.png)

指示函数：它通常用来表示一个集合或区域在某个点处的存在性或特征，比如 x 属于集合 A，则值为 1，否则值为 0。指示函数一般是一个离散的函数，它的取值只能是 0 或 1。在**实践**中，为了方便计算和优化，指示函数通常会被近似成一个连续函数，例如 sigmoid 函数（神经网络最后一层）或高斯函数等。此外，指示函数还可以被扩展到多维空间或更一般的情况下，例如对于一个区域而言，它的指示函数可以表示为一个布尔函数或特征函数。

连结：目前的理解是将两个数或者连接起来，后续遇到具体情况再更正。

集合的基数：在数学集合论中，基数或势，即集合中包含的元素的“个数”（参见势的比较），是日常交流中基数的概念在数学上的精确化（并使之不再受限于有限情形）。有限集合的基数，其意义与日常用语中的“基数”相同，例如{a,b,c}的基数是3。无限集合的基数，其意义在于比较两个集的大小，例如整数集和有理数集的基数相同；整数集的基数比实数集的小。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241681587-fc868e49-a839-4c80-9dca-3b99bc76d1ee.png)

![image](https://cdn.nlark.com/yuque/__latex/65966b512f118fcc00b8c60ae86b2de1.svg)是确定性的导数，![image](https://cdn.nlark.com/yuque/__latex/c98403508ed4f41213e396ea80b4523e.svg)是针对某一个变量的偏导数，![image](https://cdn.nlark.com/yuque/__latex/27b721d01b9148116a9d33733ec320b8.svg)是 y 关于 x 的梯度，看清上下标，下标是对那个变量求梯度。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241692797-adb9c07f-dd63-4745-88e6-5e262df76cd9.png)

![image](https://cdn.nlark.com/yuque/__latex/372f84f135fa4e6a05fbb46968bf1b97.svg)是 X 在 Y 的条件下的概率。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241708825-fabf10cf-3f8c-422e-9cd5-8c6eefddfba8.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719241717410-1dbb97f7-ad8b-4347-b691-7d7ee0074814.png)

<h3 id="fRoPa">引言</h3>
人们常用的计算机程序几乎都是软件开发人员从零编写的。 比如，现在开发人员要编写一个程序来管理网上商城。根据业务逻辑设计自动化系统，驱动正常运行的产品和系统，是一个人类认知上的非凡壮举。

但是要编写一个应用程序，向用户推荐他们可能喜欢，但在自然浏览过程中不太可能遇到的产品。在这些情况下，即使是顶级程序员也无法提出完美的解决方案。_**机器学习**_（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高。 相反，对于刚刚所说的电子商务平台，如果它一直执行相同的业务逻辑，无论积累多少经验，都不会自动提高，除非开发人员认识到问题并更新软件

<h4 id="o7UsC">日常中的机器学习</h4>
现在，假如需要我们编写程序来响应一个“唤醒词”（比如“Alexa”“小爱同学”和“Hey Siri”）。 我们试着用一台计算机和一个代码编辑器编写代码，如 图1.1.1中所示。 问题看似很难解决：麦克风每秒钟将收集大约44000个样本，每个样本都是声波振幅的测量值。而该测量值与唤醒词难以直接关联。那又该如何编写程序，令其输入麦克风采集到的原始音频片段,输出是否（表示该片段是否包含唤醒词）的可靠预测呢？我们对编写这个程序毫无头绪，这就是需要机器学习的原因。

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1719243013957-9ca0c7b7-f0e9-4bdd-9f65-185d773c332a.svg)

图1.1.1 识别唤醒词

即使我们不知道如何编写计算机程序来识别“Alexa”这个词，大脑自己也能够识别它。 有了这一能力，我们就可以收集一个包含大量音频样本的**数据集**（dataset），并对包含和不包含唤醒词的样本进行标记。 利用机器学习算法，我们不需要设计一个“明确地”识别唤醒词的系统。 相反，我们只需要定义一个灵活的程序算法，其输出由许多**参数**（parameter）决定，然后使用数据集来确定当下的“最佳参数集”，这些参数通过某种性能度量方式来达到完成任务的最佳性能。

参数可以被看作旋钮，旋钮的转动可以调整程序的行为。 任一调整参数后的程序被称为**模型**（model）。 通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“模型族”。 使用数据集来选择参数的元程序被称为**学习算法**（learning algorithm）。

在开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定**输入 **（input）和**输出**（output）的性质，并选择合适的模型族。

在机器学习中，**学习**（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据**训练**（train）模型。 如图1.1.2所示，训练过程通常包含如下步骤：

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1719243592983-8993ec79-51dd-4085-9b94-3e9203a4ddfb.svg)

图1.1.2 一个典型的训练过程

<h4 id="bbuIg">机器学习中的关键组件</h4>
1. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">可以用来学习的</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">数据</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（data）；</font>
2. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">如何转换数据的</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">模型</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（model）；</font>
3. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">一个</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">目标函数</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（objective function），用来量化模型的有效性；</font>
4. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">调整模型参数以优化目标函数的</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">算法</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（algorithm）。</font>

<h5 id="FU9JN">数据</h5>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">每个数据集由一个个</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">样本</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（example, sample）组成，大多时候，它们遵循</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">独立同分布</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">(independently and identically distributed, i.i.d.)。 样本有时也叫做</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">数据点</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（data point）或者</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">数据实例</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（data instance），通常每个样本由一组称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">特征</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（features，或</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">协变量</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 在上面的监督学习问题中，要预测的是一个特殊的属性，它被称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">标签</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（label，或</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">目标</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（target））。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">维数</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（dimensionality）。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 与传统机器学习方法相比，深度学习的一个主要优势是可以处理</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">不同长度</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的数据。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 数据集的由小变大为现代深度学习的成功奠定基础。 在没有大数据集的情况下，许多令人兴奋的深度学习模型黯然失色。 就算一些深度学习模型在小数据集上能够工作，但其效能并不比传统方法高。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">数据很重要！当数据不具有充分代表性，甚至包含了一些社会偏见时，模型就很有可能有偏见。</font>

<h5 id="pyibg"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">模型</font></h5>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">大多数机器学习会涉及到数据的转换。 比如一个“摄取照片并预测笑脸”的系统。再比如通过摄取到的一组传感器读数预测读数的正常与异常程度。 虽然简单的模型能够解决如上简单的问题，但本书中关注的问题超出了经典方法的极限。 深度学习与经典方法的区别主要在于：深度学习关注的是功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度学习</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（deep learning）。</font>

<h5 id="XTITQ"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">目标函数</font></h5>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，这被称之为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">目标函数</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">损失函数</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（loss function，或cost function）。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当任务在试图预测数值时，最常见的损失函数是</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">平方误差</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">最小化错误率</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">替代目标</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 在一个数据集上，我们可以通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">训练数据集</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（training dataset，或称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">训练集</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的性能，这里的“新数据集”通常称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">测试数据集</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（test dataset，或称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">测试集</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（test set））。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">综上所述，可用数据集通常可以分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。 </font>

<h5 id="cEX6y"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">优化算法</font></h5>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">–</font>**_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">梯度下降</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</font>

<h4 id="hg5yO"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">各种机器学习问题</font></h4>
<h5 id="gUlql">监督学习</h5>
_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">监督学习</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">样本</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">映射</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">到标签（即预测）。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">监督学习一般分为三个步骤：</font>

1. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；</font>
2. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；</font>
3. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。</font>

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1719844684922-9e400e3a-fdb6-4e23-9a2b-d8ea8925be61.svg)

监督学习

<h6 id="lhtCu">回归</h6>
回归是利用已有的特征向量去预测标签，<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">回归的目标是生成一个模型或者函数，使它的预测非常接近实际标签值，一般采用平方误差损失函数最小化。比如说用最小二乘法拟合一条曲线就是回归。</font>

<h6 id="ZTVqA"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">分类</font></h6>
_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">分类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">问题希望模型能够预测样本属于哪个</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">类别</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（category，正式称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（class））。 最简单的分类问题是只有两类，这被称之为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">二项分类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（binomial classification）。 例如，数据集可能由动物图像组成，标签可能是猫和狗两类。 回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">其实将输出的数值进行认为划分也可以变成分类，比如输入一个的概率是 0.9，我就认为是这一类。</font>_

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当有两个以上的类别时，我们把这个问题称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">多项分类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（multiclass classification）问题。 常见的例子包括手写字符识别 0-9 和 26 个字母。 与解决回归问题不同，分类问题的常见损失函数被称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">交叉熵</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（cross-entropy），本书 </font>[3.4节](https://zh.d2l.ai/chapter_linear-networks/softmax-regression.html#sec-softmax)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 将详细阐述。</font>

<h6 id="GOv4N"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">标记问题</font></h6>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">学习预测不相互排斥的类别的问题称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">多标签分类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（multi-label classification）。比如下面这个图片里面有各种动物，使用多项分类输出这是什么动物明显不符合日常认知，这时就需要输出这里面有哪些标签或者类别，这些类别之间是不相互排斥的，不能说里面有坤就不能有猫了。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1719845367675-439b9393-e498-408c-8b6b-85af02920255.png)

<h6 id="qA3oS">搜索</h6>
我们在搜索引擎输入关键词进行搜索时，不仅需要找到相关的内容，还需要对内容进行排序，把最相关的放到最上面，这就是**搜索**排序。<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。</font>[PageRank](https://en.wikipedia.org/wiki/PageRank)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子，但它的奇特之处在于它不依赖于实际的查询。 </font>

<h6 id="NtF1c"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">推荐</font></h6>
推荐时将用户和物品相关联起来，找到最适合这个用户的产品，给用户进行个性化推荐，当然可以按照其他人检索得分最高的产品推给一个新用户，但是现在的推荐算法会考虑到详细的用户行为和项目特征。

推荐带来的一个灾难性问题是用的多的东西用的越多，但是这个产品并不一定是最好的，可能对于某个用户来说。

<h6 id="SvRbd">序列学习</h6>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">以上大多数问题都具有固定大小的输入和产生固定大小的输出。 但是对于翻译来说，输入和输出的大小不是固定的，甚至目前的输入还要和之前的输入有关联，输入之间不是相互独立的，比如在翻译时需要考虑上下文的含义。还有一个例子就是语音识别，输入是一段音频，输出是文字，音频采样通常是 8k hz 或者 16k hz，这里输入和输出就是数千个样本对应一个输出，反过来还有文字生成语音等等。</font>

<h5 id="eRKN5"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">无监督学习</font></h5>
监督学习通常是输入的样本中包含特征和对应的标签值，但是无监督学习是样本中没有标签。

无监督学习主要解决下面几个问题：

+ _<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">聚类</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（clustering）问题：没有标签的情况下，我们是否能给数据分类呢？比如，给定一组照片，我们能把它们分成风景照片、狗、婴儿、猫和山峰的照片吗？同样，给定一组用户的网页浏览记录，我们能否将具有相似行为的用户聚类呢？</font>
+ _<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">主成分分析</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。再比如，裁缝们已经开发出了一小部分参数，这些参数相当准确地描述了人体的形状，以适应衣服的需要。另一个例子：在欧几里得空间中是否存在一种（任意结构的）对象的表示，使其符号属性能够很好地匹配?这可以用来描述实体及其关系，例如“罗马”</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">−</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">“意大利”</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">+</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">“法国”</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">=</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">“巴黎”。</font>
+ _<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">因果关系</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（causality）和</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">概率图模型</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系？</font>
+ _**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">生成对抗性网络</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域。</font>

<h5 id="p9UTx">与环境交互</h5>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">离线学习</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（offline learning）。对于监督学习，从环境中收集数据的过程类似于下图。</font>

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1719846511298-62844f03-7890-4d5f-9153-509e5078d205.svg)

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">监督学习解决的问题相当有限，因为只有当时离线的数据，除非离线的数据包含所有情况，实际上不可能，数据量太庞大了。 这时我们可能会期望人工智能不仅能够做出预测，而且能够与真实环境互动。 与预测不同，“与真实环境互动”实际上会影响环境。这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</font>

<h5 id="hKCU7">强化学习</h5>
_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度强化学习</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（deep reinforcement learning）将深度学习应用于强化学习的问题，是非常热门的研究领域。 突破性的</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度</font>**_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">Q网络</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（Q-network）在雅达利游戏中仅使用视觉输入就击败了人类， 以及 AlphaGo 程序在棋盘游戏围棋中击败了世界冠军，是两个突出强化学习的例子。</font>

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1719846723482-822849a1-dd0f-41c6-ba64-35a1ba739771.svg)

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，可以创建一个强化学习智能体，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予智能体的奖励。 这个奖励与原始监督学习问题的损失函数是一致的。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当然，强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望输入与正确的标签相关联。 但在强化学习中，我们并不假设环境告诉智能体每个观测的最优动作。 一般来说，智能体只是得到一些奖励。 此外，环境甚至可能不会告诉是哪些行为导致了奖励。所以智能体需要找到其中的内在联系。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">最后，在任何时间点上，强化学习智能体可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习智能体必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">当环境可被完全观察到时，强化学习问题被称为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">马尔可夫决策过程</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（markov decision process）。 当状态不依赖于之前的操作时，我们称该问题为</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">上下文赌博机</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（contextual bandit problem）。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的</font>_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">多臂赌博机</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（multi-armed bandit problem）。</font>

<h4 id="plhD9"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">特点</font></h4>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">机器学习可以使用数据来学习输入和输出之间的转换，例如在语音识别中将音频转换为文本。 在这样做时，通常需要以适合算法的方式表示数据，以便将这种表示转换为输出。 深度学习是“深度”的，模型学习了许多“层”的转换，每一层提供一个层次的表示。 例如，靠近输入的层可以表示数据的低级细节，而接近分类输出的层可以表示用于区分的更抽象的概念。 由于</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">表示学习</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（representation learning）目的是寻找表示本身，因此深度学习可以称为“多级表示学习”。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">从原始音频信号中学习，图像的原始像素值，或者任意长度的句子与外语中的对应句子之间的映射，都是深度学习优于传统机器学习方法的问题。 事实证明，这些多层模型能够以以前的工具所不能的方式处理低级的感知数据。 </font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度学习方法中最显著的共同点是使用端到端训练。 也就是说，与其基于单独调整的组件组装系统，不如构建系统，然后联合调整它们的性能。 例如，在过去的计算机视觉中，科学家们习惯于将特征工程的过程与建立机器学习模型的过程分开。 Canny边缘检测器 (</font>[Canny, 1987](https://zh.d2l.ai/chapter_references/zreferences.html#id20)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">) 和SIFT特征提取器 (</font>[Lowe, 2004](https://zh.d2l.ai/chapter_references/zreferences.html#id102)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">) 作为将图像映射到特征向量的算法，在过去的十年里占据了至高无上的地位。 在过去的日子里，将机器学习应用于这些问题的关键部分是提出人工设计的特征工程方法，将数据转换为某种适合于浅层模型的形式。 然而，与一个算法自动执行的数百万个选择相比，人类通过特征工程所能完成的事情很少。 当深度学习开始时，这些特征抽取器被</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">自动调整的滤波器</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">所取代，产生了更高的精确度。即不需要人为的设置特征工程，使用学习的方法不断进行尝试，进行更多维度更精细的尝试，最极端的例子就是暴力搜索最后的结果一定是最优的。</font>

<h4 id="kenOu"><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">小结</font></h4>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">通过GPU）算力</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的突破来触发的。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易。</font>

<h3 id="q50tC">预备知识</h3>
<h4 id="PUgqa">数据操作</h4>
n 维数组在 pytorch 和 tensorflow 中叫做张量类（tensor）,tensor 支持自动微分，并且支持 GPU 加速计算。

张量需要指定在 GPU 上才能加速计算，否则默认是在内存中，基于 CPU 计算。

torch.shape 返回张量沿每个轴的形状。

torch.size 返回张量中元素的总数

torch.reshape（x, y）可以将改变一个张量的形状，但张量的大小不会变；

标准运算符加减乘除、求指数等等都是对张量中的元素进行计算；

torch.cat（（x, y），dim=0) 可以把两个张量按照指定的轴进行连接起来。

**广播**机制：两个形状不一样的张量，可以通过广播机制变为同一个形状，然后在进行按元素操作计算。

张量可以提供数组来进行索引特定的数组，这些数组可以不连续。

不过要注意的是，张量必须要大小一致，即列表中的每个数组的大小是一样的，否则不能转为 tensor；

为了节省内存，可以将新计算的结果存储到原数组中。比如 x=x+y 这种；

张量变为标量可以使用.item（）但是这个只能一个元素进行转换。

x>y 得到是一个布尔型的张量，其中的结果由 x 和 y 中的元素进行比较得到；

```plain
torch.arange(20).reshape(5, 4)
```

arange 是生成一个 0-19 的 tensor 一维张量，然后 reshape 将这个一维张量变为 5*4 的张量形状。

<h4 id="DAKK4">数据预处理</h4>
处理缺失值可以采用 fillna（x），这将读取的数据中缺失的值用 x 来填充。

<h4 id="tT2IG">线性代数</h4>
两个张量点乘是用"*"来计算，针对每个元素进行计算，

可以通过求和或者求均值来降低张量指定轴的维度；

两个张量点积是用 dot(x, y)来计算；

矩阵向量积使用 torch.mv(x, y)；  
矩阵相乘使用 torch.mm(x, y);

范数的性质：

1. <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">如果我们按常数因子</font>![image](https://cdn.nlark.com/yuque/__latex/18d25ca4f77a9bbed9812e2bb0b350a5.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">缩放向量的所有元素， 其范数也会按相同常数因子的</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">绝对值</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">缩放：</font>![image](https://cdn.nlark.com/yuque/__latex/5254e7fc1786b42afc64a5ef9a94c025.svg)
2. 满足三角不等式：![image](https://cdn.nlark.com/yuque/__latex/752c695aff9ceec80e733668167b46ba.svg)
3. 范数必须是非负的：![image](https://cdn.nlark.com/yuque/__latex/51ea5e525d421cabaf77475c21b506a9.svg)当且仅当向量全为 0 时，范数才是 0.

常见的二范数![image](https://cdn.nlark.com/yuque/__latex/6cbe0ba6e4bf4752f798869df1da73bf.svg)是欧几里得距离：![image](https://cdn.nlark.com/yuque/__latex/c0e3337f72837db0e425285fcc4074f2.svg)通常情况下省略下标 2，变为![image](https://cdn.nlark.com/yuque/__latex/7fcea29dc55a707c04963b69589f7763.svg)。

一范数![image](https://cdn.nlark.com/yuque/__latex/8774782e75650651e5d3a5ded5c77e44.svg)是所有元素的绝对值之和：![image](https://cdn.nlark.com/yuque/__latex/73c5510b8cacaa97ede10ae77c368721.svg)一范数受异常值的影响相较于二范数会比较小，因为不需要平方。

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">类似于向量的</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">二</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">范数，矩阵</font>![image](https://cdn.nlark.com/yuque/__latex/5df80402f7d42243460d9c8e1b937952.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">Frobenius范数</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（Frobenius norm）是矩阵元素平方和的平方根：</font>![image](https://cdn.nlark.com/yuque/__latex/76eb0979282f51c93411e94633c38e47.svg)

**小结**：

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">标量、向量、矩阵和张量是线性代数中的基本数学对象。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">向量泛化自标量，矩阵泛化自向量。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">标量、向量、矩阵和张量分别具有零、一、二和任意数量的轴。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">一个张量可以通过</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">sum</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">和</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">mean</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">沿指定的轴降低维度。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">两个矩阵的按元素乘法（即对应元素直接相乘）被称为他们的Hadamard积。它与矩阵乘法（第一个矩阵第一行乘第二个矩阵第一列）不同。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">在深度学习中，我们经常使用范数，如</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">一</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">范数、</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">二</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">范数和Frobenius范数。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">我们可以对标量、向量、矩阵和张量执行各种操作。</font>

<h4 id="JQVEF">微积分</h4>
导数的定义：![image](https://cdn.nlark.com/yuque/__latex/af1072d62df6c92bc459951678e19c42.svg)

给定![image](https://cdn.nlark.com/yuque/__latex/e636c536eaf5442066005a809249aea6.svg)那么以下表示式是等效的:

![image](https://cdn.nlark.com/yuque/__latex/f7a66a0685d0d6d2f9ad4e2a5ea41675.svg)

导数有乘法法则 、加法法则、乘法法则和除法法则，其中乘法法则为：

![image](https://cdn.nlark.com/yuque/__latex/5dd961e74898959b3d70294c3a002a47.svg)

除法法则为：

![image](https://cdn.nlark.com/yuque/__latex/a64075c15f0434edaf6f56805466eb00.svg)

假设![image](https://cdn.nlark.com/yuque/__latex/0f0f2f66ced85959857b9c8a7777e885.svg)是具有 n 个变量的函数，则关于第 i 个变量的偏导数定义：![image](https://cdn.nlark.com/yuque/__latex/6bead467e91e902a894de9146f3e8ad7.svg)

在计算偏导数时，可以将其他变量当做常数：

![image](https://cdn.nlark.com/yuque/__latex/99e88dae32beded60aea62cc98baa5dd.svg)

**梯度**：把一个多元函数对所有变量的偏导数连结起来就是这个函数的梯度（gradient）向量，假设函数的输入是一个 n 维向量：![image](https://cdn.nlark.com/yuque/__latex/2b422c60615acb7744c31866d5f8077e.svg)，那么<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">函数</font>![image](https://cdn.nlark.com/yuque/__latex/d1fed5d79d625df8f8cc788edf0f0328.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">相对于</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> x </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的梯度是一个包含</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> n </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">个偏导数的向量:</font>![image](https://cdn.nlark.com/yuque/__latex/86966022be2eb63e11e01921a214c1da.svg)

在微分多元函数时经常使用以下规则：

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">对于所有</font>![image](https://cdn.nlark.com/yuque/__latex/ce93bb4a23a774bc0da16df81cecf52b.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，都有</font>![image](https://cdn.nlark.com/yuque/__latex/10f0f9dd3be7340f317ee5700a78c0ff.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，因为只有对角线上的元素在求偏导数时才为 1，其他位置都是 0，因为在求偏导数时，其他变量相当于常数。Ax 的结果是一个列向量，然后依次对每一行求偏导数，对 x1 求偏导的结果是一个列向量，分别是 a11,a21,a31...这种，然后观察梯度的公式，是将求得每一个偏导数连结成一行，然后进行转置，也就是说 Ax 对每一个变量 x 求完偏导数之后，都是一个个列向量，然后连结成一个矩阵，恰巧连结的矩阵就是原矩阵 A，然后进行转置就是 A 的转置。其他同理。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">对于所有</font>![image](https://cdn.nlark.com/yuque/__latex/6767e8a20e067bdab3b882f860ffad84.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，都有</font>![image](https://cdn.nlark.com/yuque/__latex/91f8934b92dcb329e754274d53ea5f68.svg)
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">对于所有</font>![image](https://cdn.nlark.com/yuque/__latex/bd4b0a03c7a35668a9ab8058a94f1fa0.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，都有</font>![image](https://cdn.nlark.com/yuque/__latex/3131129efbc67585259c00051504ea8f.svg)
+ ![image](https://cdn.nlark.com/yuque/__latex/41b8f41aaabe94a023e186631ec28f1d.svg)

**链式法则**：<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">考虑一个更一般的场景，即函数具有任意数量的变量的情况。 假设可微分函数</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> y </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">有变量</font>![image](https://cdn.nlark.com/yuque/__latex/0a99bec2d00a035e4ba01601133bce01.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，每个可微分的函数 </font>![image](https://cdn.nlark.com/yuque/__latex/cd0edf8a05e48bdf774e84989c25e619.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 都有变量</font>![image](https://cdn.nlark.com/yuque/__latex/e42a368f041262444bfc3ddbaf1dd313.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，那么 y 对于 x 的导数为：</font>

![image](https://cdn.nlark.com/yuque/__latex/2965920a4f1ed03c95db839c6bad39e0.svg)

y 需要对所有的中间变量 u 进行求导，然后中间变量 u 再对 x 求导。

**小结**：

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">导数可以被解释为函数相对于其变量的瞬时变化率，它也是函数曲线的切线的斜率。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">链式法则可以用来微分复合函数。</font>

<h4 id="ZKite">自动微分</h4>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度学习框架通过自动计算导数，即</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">自动微分</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（automatic differentiation）来加快求导。 实际中，根据设计好的模型，系统会构建一个</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">计算图</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度。 这里，</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">反向传播</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">自动微分之前，需要将梯度附加到需要求梯度的变量 x 上，</font>

```plain
x.requires_grad_(True)  # 等价于x=torch.arange(4.0,requires_grad=True)
```

y 是 x 的函数，比如 y = 2 * torch.dot(x, x)，然后对函数 y 调用反向传播函数来自动计算 y 关于 x 每个分量的梯度，然后访问 x 的梯度。

```plain
y.backward()
x.grad
```

对于函数 y 不是标量的时候，求导的结果可以是一个高阶的张量，只不过要保证 y 对于 x 是可微的。

**分离计算**：即在计算梯度的时候不计算中间变量的梯度。

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">假设</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">是作为</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的函数计算的，而</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">z</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">则是作为</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">和</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的函数计算的。 我们想计算</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">z</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">关于</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的梯度，但由于某种原因，希望将</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">视为一个常数， 并且只考虑到</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">在</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">被计算后发挥的作用。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">这里可以分离</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">来返回一个新变量</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">u</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，该变量与</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">具有相同的值， 但丢弃计算图中如何计算</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">y</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的任何信息。 换句话说，梯度不会向后流经</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">u</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">到</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">。 因此，下面的反向传播函数计算</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">z=u*x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">关于</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的偏导数，同时将</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">u</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">作为常数处理， 而不是</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">z=x*x*x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">关于</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">x</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">的偏导数。</font>

**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">控制流梯度计算</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">：当构建函数的计算图需要通过控制流（就是 if  for 等循环条件或者任意的函数）时，如果手动计算微分需要考虑各种情况，而自动微分不需要手动计算，它可以自动解析计算图中的所有控制流，提高效率。</font>

**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">小结</font>**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">：</font>

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">深度学习框架可以自动计算导数：我们首先将梯度附加到想要对其计算偏导数的变量上，然后记录目标值的计算，执行它的反向传播函数，并访问得到的梯度。</font>

<h4 id="KLcUJ">概率</h4>
**贝叶斯**公式：

![image](https://cdn.nlark.com/yuque/__latex/45760c5c608058b26eb68e3d20fdf47e.svg)

**多元变量**的贝叶斯公式：

<font style="color:rgb(77, 77, 77);">P(A|B,C)=P(A,B,C)/P(B,C)</font>

<font style="color:rgb(77, 77, 77);"></font><font style="color:rgb(77, 77, 77);">=</font><font style="color:rgb(77, 77, 77);">P(C|A,B)*P(A,B)/P(B,C)</font>

<font style="color:rgb(77, 77, 77);">= P(C|A,B)*P(B|A)*P(A)/P(C|B)*P(B)</font>

**<font style="color:rgb(77, 77, 77);">边际化</font>**<font style="color:rgb(77, 77, 77);">：即不直接计算 B 的概率，而是将所有 AB 的概率进行求和，得到 B 的概率</font>

![image](https://cdn.nlark.com/yuque/__latex/7e8369ccb369315144ac921f6e453d62.svg)

**独立**性：![image](https://cdn.nlark.com/yuque/__latex/1035fc4f6c32915e25264dae811d1b1a.svg)

**期望**：连续变量的期望为：![image](https://cdn.nlark.com/yuque/__latex/aaaaea64f223eb9039f04fa6c92d1108.svg)

离散变量的期望为：![image](https://cdn.nlark.com/yuque/__latex/2c554d68e9370bd58f73607526b071eb.svg)

**方差**：![image](https://cdn.nlark.com/yuque/__latex/0aa87af2c35109cf09be2d2cfbd34fd1.svg)

因为![image](https://cdn.nlark.com/yuque/__latex/94032d5ab1b4916bc718cb507a6887e2.svg)

**小结**：

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">我们可以从概率分布中采样。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">我们可以使用联合分布、条件分布、Bayes定理、边缘化和独立性假设来分析多个随机变量。</font>

<h4 id="YyGCI">查阅文档</h4>
<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">可以调用</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">dir</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">函数。 例如，我们可以查询随机数生成模块中的所有属性：</font>

```plain
import torch

print(dir(torch.distributions))
```

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">有关如何使用给定函数或类的更具体说明，可以调用</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">help</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">函数。 例如，我们来查看张量</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">ones</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">函数的用法。</font>

```plain
help(torch.ones)
```

<h3 id="lJ9Ip">线性神经网络</h3>
<h4 id="FEN6k">线性回归基础知识</h4>
线性回归的的数据集称为训练数据集或者数据样本，预测的目标称为标签或者目标，预测所依据的自变量称为特征或者协变量。

线性回归的模型是：![image](https://cdn.nlark.com/yuque/__latex/5d41eb9b218de1a9fb13540c1b422804.svg)，给定训练数据的特征 X 和已知标签 y，线性回归的目标是找到一组权重向量 w 和偏置 b，当给定从 X 的同分布中取样的新样本特征时，能够使预测的标签误差尽可能小。

_**<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">损失函数</font>**_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（loss function）能够量化目标的</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">实际</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">值与</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">预测</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">值之间的差距。 通常我们会选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0。 回归问题中最常用的损失函数是平方误差函数。 </font>

![image](https://cdn.nlark.com/yuque/__latex/0f56fc54c478904905a454b0ff607917.svg)

对于无法得到解析解的损失函数，通常是使用梯度下降的方式更新参数，梯度下降是计算数据集中所有样本的损失均值关于模型参数的导数，为了加快计算速度，通常是随机抽取一小批样本进行梯度下降的计算，这叫做小批量随机梯度下降。

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">在每次迭代中，我们首先随机抽样一个小批量</font>![image](https://cdn.nlark.com/yuque/__latex/9e0b92d19bdf738dc2a21b6f447fad1f.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">， 它是由固定数量的训练样本组成的。 然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">学习率</font>![image](https://cdn.nlark.com/yuque/__latex/7483c6745bb07f292eba02b3a9b55c26.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">，并从当前参数的值中减掉。</font>

![image](https://cdn.nlark.com/yuque/__latex/245075027c4be840f01e2c40dbb7cf75.svg)

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的。 这些可以调整但不在训练过程中更新的参数称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">超参数</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（hyperparameter）。 </font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">调参</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（hyperparameter tuning）是选择超参数的过程。 超参数通常是我们根据训练迭代结果来调整的， 而训练迭代结果是在独立的</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">验证数据集</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（validation dataset）上评估得到的。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">对像深度神经网络这样复杂的模型来说，损失平面上通常包含多个最小值。难做到的是找到一组参数，这组参数能够在我们从未见过的数据上实现较低的损失， 这一挑战被称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">泛化</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">（generalization）。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">矢量化计算可以使计算时间减少数量级倍。</font>

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">正态分布也叫做高斯分布，概率密度函数为：</font>

![image](https://cdn.nlark.com/yuque/__latex/b95e40417cd4b7c8c40203326ceb14b5.svg)

**似然函数**是概率的逆过程，和最小二乘法求参数一样，都是利用已有的数据点样本去求得满足该数据分布的参数。

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是： 我们假设了观测中包含噪声，其中噪声服从正态分布。 噪声正态分布如下式:</font>

![image](https://cdn.nlark.com/yuque/__latex/92f505df2ce4cfe1d4bda311595e4f43.svg)

其中噪声服从正态分布：![image](https://cdn.nlark.com/yuque/__latex/0aba72d7b8fb8d340809d13382148dbd.svg)

那么通过给定 x 观测到特定 y 的**似然（likehood）**为：

![image](https://cdn.nlark.com/yuque/__latex/75ae8f6c757fcfa2e0091761615cfb8b.svg)

因为 x 是给定的，所以 y 的分布就是在噪声的基础之上加上了一个常数，也就是说 y 的分布是噪声的正态分布加上常数![image](https://cdn.nlark.com/yuque/__latex/4a5935eb6e6a5a2e85fb1096106a3ef1.svg)，那么 y 的方差不会改变，均值从 0 变为了![image](https://cdn.nlark.com/yuque/__latex/4a5935eb6e6a5a2e85fb1096106a3ef1.svg)，所以 y 的概率分布也就变成了上式，因为方差和噪声的方差是一样的，加上常数不会改变方差。

![image](https://cdn.nlark.com/yuque/__latex/e680478f183b56bdfe4a7a4f90c82b3b.svg)

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">根据极大似然估计法选择的估计量称为</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">极大似然估计量</font>_<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">。由于乘积很难计算，通常通过取对数来简化计算过程。</font>

![image](https://cdn.nlark.com/yuque/__latex/91f31710fca8419d44c98e991576d5ed.svg)

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">现在我们只需要假设</font>![image](https://cdn.nlark.com/yuque/__latex/788df1ba344b3092def7590d1be6b4d4.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">是某个固定常数就可以忽略第一项， 因为第一项不依赖于</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">w</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">和</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">b</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">。 现在第二项除了常数</font>![image](https://cdn.nlark.com/yuque/__latex/281ef8416347422aa501052fa5e6fa24.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">外，其余部分和前面介绍的均方误差是一样的。 幸运的是，上面式子的解并不依赖于</font>![image](https://cdn.nlark.com/yuque/__latex/788df1ba344b3092def7590d1be6b4d4.svg)<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">。 因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。</font>

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1722497389351-aa5023bb-f8cd-401c-989e-515e6c4e8813.svg)

线性回归是一个单层神经网络

 由于模型重点在发生计算的地方，所以通常我们在计算层数时**不考虑输入层**。

**小结：**

+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">机器学习模型中的关键要素是训练数据、损失函数、优化算法，还有模型本身。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">矢量化使数学表达上更简洁，同时运行的更快。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">最小化目标函数和执行极大似然估计等价。</font>
+ <font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">线性回归模型也是一个简单的神经网络。</font>

<h4 id="oDVyH">线性回归的代码实现</h4>
线性回归的模型是单层网络架构，只有一个全连接层，所以模型可以定义为：

```plain
# nn是神经网络的缩写
from torch import nn

net = nn.Sequential(nn.Linear(2, 1))
```

可以通过 net[0] 访问第一层，然后使用`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">weight.data</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">和</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">bias.data</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">方法访问参数。 我们还可以使用替换方法</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">normal_</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">和</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">fill_</font>`<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">来重写参数值。  
</font>

```plain
net[0].weight.data.normal_(0, 0.01)
net[0].bias.data.fill_(0)
```

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">损失函数一般使用均方误差，即 L2 范数，计算所有样本损失的均值；</font>

```plain
loss = nn.MSELoss()
```

训练过程是不停的获取一个小批量的数据，然后对这个小批量的数据进行以下三步计算：

+ 调用 net（X） 生成预测值并计算损失值，即前向传播；
+ 通过反向传播计算梯度；
+ 通过调用优化器来更新模型的参数，优化器包括随机梯度下降、Adam 等；

```plain
num_epochs = 3
for epoch in range(num_epochs):
    for X, y in data_iter:
        l = loss(net(X) ,y)
        trainer.zero_grad()
        l.backward()
        trainer.step()
    l = loss(net(features), labels)
    print(f'epoch {epoch + 1}, loss {l:f}')
```

<h4 id="vptAR">softmax 回归的基础知识</h4>
监督学习中的估计不只有预测某个值，即使是预测估计某个值，也不是只有最小化平方误差这种线性回归模型；softamax 主要用来解决**分类**的问题。

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1722859354988-35564838-e5fe-4e68-8d64-217196a58193.svg)

softmax 是一个单层的神经网络模型，是一个线性模型，输入和输出之间是仿射变换

分类问题中不同的类别之间没有自然的排序顺序，即不同的类别在排序时不能简单地按照 1，2，3 这种自然数进行排序，所以**独热编码（one hot）**用来表示分类数据。独热编码是一个向量，向量的大小和类别的数量相同，对应的元素为 1，其余的元素为 0，即![image](https://cdn.nlark.com/yuque/__latex/ab461a05402bc604ffde2aeb247d3b62.svg)表示猫，![image](https://cdn.nlark.com/yuque/__latex/7fcdf187e08b14b53ca03de9ad7615ba.svg)表示鸡，![image](https://cdn.nlark.com/yuque/__latex/11de25379c4079ae8493de2cd3d59622.svg)表示狗这种，![image](https://cdn.nlark.com/yuque/__latex/cdc6d494e02ff59c5e37a5554ddcafd5.svg)

为了将所有预测的分类的概率之和限制为 1，并且保证预测的概率都是非负的（因为概率不可能小于 0），在这里使用指数函数并进行正则化，输出的概率 o 首先使用指数函数，将其转化为非负数，然后再将其除以所有预测概率之和来保证最后输出的概率在 0-1 之间。值得注意的是 **softmax 仍然是线性模型**。

![image](https://cdn.nlark.com/yuque/__latex/568cfeb9eb9c2c20df7fd36e989227af.svg)

**损失函数**

为了更新模型的参数，softmax 中依然是基于最大似然估计来更新模型的参数。对于任意给定的输入 x，估计的每个类的条件概率

![image](https://cdn.nlark.com/yuque/__latex/54f5af76eb189ff475947a7522c25546.svg)

![image](https://cdn.nlark.com/yuque/__latex/442b3c4b660b1a8441b125a5d8b27772.svg)

因为标签是 one hot 编码，所以只有对应的类别是 1，其余全为 0，所以这个条件概率实际上就是![image](https://cdn.nlark.com/yuque/__latex/237bd4109450a26f96e85fc5fb813597.svg),所以最后的损失函数如下所示就是交叉熵。

![image](https://cdn.nlark.com/yuque/__latex/9ea68b84c8d13a7ae867d4bfc400212f.svg)

为了对交叉熵损失函数理解的更深一些，将 softmax 函数带入交叉熵损失函数中得到：

![image](https://cdn.nlark.com/yuque/__latex/8294baa696e170c55fbe4bdc9a1b5ee7.svg)

然后对 oj 进行求导得到下式，对于第一项求导，由于是复合函数，所以分子是各项之和，而分子是对这个和求导，由于是 one hot 编码，所以只有对应的 oj 才为 1，其余项对于 oj 来说全是 0，所以分支只有一项 exp(oj)，对于第二项只所以不能把 yj 去掉，是因为 yj 和 oj 是联合在一起的，用于表示只有在第 j 项时才有 oj，因为 yj 就是 1。交叉熵损失函数求导的结果和在回归模型中求导的结果是类似的，都是可以转化为交叉熵的损失函数的。

![image](https://cdn.nlark.com/yuque/__latex/6d3fd6ae1eddc20a1cfdf861d2347a7e.svg)

需要注意的是，交叉熵损失函数在计算的时候可能会由于 oj 比较大，导致计算的指数超过范围，产生溢出，所以在计算的时候可以将输出的 oj 减去最大的 oj 然后再进行 softmax 计算，这样所有的 oj 都是小于等于 0 的，不会产生上溢的风险；

![image](https://cdn.nlark.com/yuque/__latex/902dc725e02dfcf8eecd2f1e2e7f1f3b.svg)

为了避免下溢，我们采用对数交叉熵损失函数：

![image](https://cdn.nlark.com/yuque/__latex/1af5b293ad0b0165355bb5027571719b.svg)

**信息论基础知识**

一个事件包含的信息量为：

![image](https://cdn.nlark.com/yuque/__latex/03821c413bbdf44192aa59c1f031df97.svg)

信息论的主要核心是量化数据中包含多少信息量，这决定了我们最少采用多少数据才能不失真的传达某个信息，因此对于一个事件集的分布 P，它的熵为下式所示，表示对所有的单个事件的自信息求期望值：

![image](https://cdn.nlark.com/yuque/__latex/225922d9921cb60f219cbe5677e8e769.svg)

这表明为了编码从分布 P 中随机抽取数据，至少需要 H(P)个 nat 来进行编码吗，nat 是以底数 e 进行计算的，而 bit 是以底数为 2 进行计算的，因此 1nat 等于![image](https://cdn.nlark.com/yuque/__latex/22d032444133c85023aba994b0a46c01.svg)比特。

编码是为了预测这一条数据流中下一个数据是什么，比如说有一条相同的数据流，每个数据都是相同的，那么这条数据流包含的信息就特别少。

交叉熵是指我们想要知道 p 分布的信息，但是 p 分布是未知的，即 p 是真实数据的分布，我们通过无法得知真实数据的概率分布；我们训练所用的数据集是采样或者其他方式获得的概率分布 q，这两个分布不是相同的，为了衡量训练得到的分布和真实分布之间的差异，采用交叉熵来进行量化：

![image](https://cdn.nlark.com/yuque/__latex/06cca99004343f2994983cdcc2e71a0a.svg)

**泛化问题**

<font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">解决以 95%的置信度得出结论，估计在测试集上的测试误差 </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">ϵD(f)</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 与在真实数据集上的真实误差 </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">ϵ(f)</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 之间的距离 </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">t</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 不超过 </font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);">0.01</font><font style="color:rgba(0, 0, 0, 0.87);background-color:rgb(250, 250, 250);"> 所需的最小数据集 n 的大小。这个计算出来的数值比真实所需的数据集的数量要大一些，但是可以作为一个大致的评估标准，表明测试集需要多少数据进行测试所达到的误差才能和，在泛化或者迁移到真实的数据集之后，所产生的真实误差相同或者类似这个事件，具有多少的置信度。</font>

![image](https://cdn.nlark.com/yuque/__latex/4fac5bf653dccd1a610bd242ad002846.svg)

有时候我们训练的数据是从某一个分布采样的，但是测试的数据是从不同的分布中采样得到的，如果不知道测试集中的分布和训练数据集的分布之间的关系，那么训练得到的分类器将不会是稳定的。

为了解决上述问题，我们可以采用协变量偏移，即尽管输入的分布可能会随着时间改变，但是条件分布![image](https://cdn.nlark.com/yuque/__latex/39b7aa6aa4d2d7371c54d64e2704b3ba.svg)不会变化，我们可以不引入因果关系来推理分布偏移。另外还有标签迁移和概念迁移；

**模型偏差矫正**

我们想要估计 p(x)的概率分布，但是训练的数据是从 q(x)中采样的，为了减少这两个概率分布之间的偏差，可以采用下式进行矫正，其中有一点需要注意的是条件分布不会改变![image](https://cdn.nlark.com/yuque/__latex/fa8d5e82de9d1034e88edb5899c51182.svg)：

![image](https://cdn.nlark.com/yuque/__latex/c9e6cc850f243fe6fea2a09ef584cc27.svg)

这相当于通过正确分布和错误分布之间的概率之比来对每个数据样本进行加权，在 PPO 中叫做重要性采样

![image](https://cdn.nlark.com/yuque/__latex/49002c4aca7e7d84c8f329d12609d9a5.svg)即使 q（x）和 p(x)分布不一样，但是可以通过这个比值来校正不一样数据的权重，即更关心 p(x)分布下的数据。

![](https://cdn.nlark.com/yuque/0/2024/png/39264174/1722911996540-a4b8b10d-b20a-4769-b138-f1fb6f0b8e03.png)

**总结**

在许多情况下，训练集和测试集来自不同的分布。这被称为分布偏移。风险是指从数据的真实分布中抽取的数据总体的损失期望。然而，整个数据集通常不可用。经验风险是通过近似风险来计算**训练集数据**上的平均损失。实践中，我们进行经验风险最小化。

在相应的假设下，可以在测试时检测和纠正协变量和标签偏移。未能考虑这种偏见在测试时可能会变得问题重重。在某些情况下，环境可能会记住自动化操作并以出乎意料的方式响应。在构建模型时，我们必须考虑到这种可能性，并继续监控实时系统，保持开放的态度，以防我们的模型和环境以未预见的方式交织在一起。

<h3 id="F03g2">多层感知器</h3>
<h4 id="njxg4">基础知识</h4>
单个输入对应单个输出的线性单元处理的应用场景相对比较简单，为了处理非线性的问题，可以通过合并多个线性层，即将许多层堆叠起来，相互连接。这种架构成为多层感知器，缩写为 MLP。

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1728475216377-25f86ee1-5463-4913-ad4f-8332763983a5.svg)

具有五个隐藏单元的隐藏层 MLP

只合并多个线性单元并不能解决非线性问题，因为本质上还是多个线性单元的累加，所以还需要使用**非线性的激活函数**来发挥 MLP 的能力。值得注意的是，激活函数使用于每个神经元，而不是对每一层使用一个激活函数。因此每个神经元都可以单独进行激活，不需要考虑其它隐藏单元的值。同时可以使用更深的网络来近似更复杂的函数。

常见的激活函数：  
ReLU：![image](https://cdn.nlark.com/yuque/__latex/2a19918f41a6385902e782d4c81d9811.svg)（0，inf)

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1728476694162-4ff561ab-c833-41d1-b574-545bb5c8fd1e.svg)

当输入为负数时，导数为 0，输入 0 时导数也为 0。

ReLU 的导数性能比较好，要么消失，要么通过，这使得优化表现得很好，缓解了 sigmoid 函数梯度消失得问题，同时 ReLU 还有一些变体，比如参数化 ReLU, 在输入为负数时，加了一个线性项，使得消息任然可以传递。![image](https://cdn.nlark.com/yuque/__latex/06621ad415adae4ab6b95cf5bdb8b811.svg)

sigmoid：![image](https://cdn.nlark.com/yuque/__latex/3430a00b1259acb499363c13e30fe642.svg)(0，1)

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1728477217811-afca69a4-2fc3-4047-a7e1-b67c4e6c3219.svg)

可以将输入压缩为 0-1，当阈值激活的输入低于某个阈值时，输出为 0，当输入超过某个阈值时，输出为 1，所以对于比较大得正负输入，梯度会消失，导致难以摆脱平台期。当 sigmoid 的输入在 0 附近时，sigmoid 函数接近为线性变换。

sigmoid 的导数为：![image](https://cdn.nlark.com/yuque/__latex/4b96fce15075d0d5ce4b2a5672ac5ba9.svg)

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1728477376706-a0cca0d1-7361-478d-84aa-86112fc198ab.svg)

在 0 附近导数最大为 0.25，输入越大或者越小，导数越接近为 0，导致梯度消失。

Tanh 函数：![image](https://cdn.nlark.com/yuque/__latex/7f68731312f9129c372ec7e0961ff242.svg)（-1，1）

tanh 函数和 sigmoid 函数很像，只不过 tanh 函数是关于原点中心对称的，输入可以是负数，导数形状和 sigmoid 函数也很像，只不过在 0 时导数可以达到 1。

![image](https://cdn.nlark.com/yuque/__latex/77de1e2783aaacd62a8183e08ad69acd.svg)

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1728477745560-8f5a660e-3196-420f-8ae8-e1302a2592aa.svg)

<h4 id="sDGBa">实现</h4>
首先需要初始化模型参数，然后对于每一层都需要设置一个权重矩阵和偏差向量。

```c
class MLPScratch(d2l.Classifier):
    def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01):
        super().__init__()
        self.save_hyperparameters()
        self.W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens) * sigma)
        self.b1 = nn.Parameter(torch.zeros(num_hiddens))
        self.W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs) * sigma)
        self.b2 = nn.Parameter(torch.zeros(num_outputs))
def relu(X):
    a = torch.zeros_like(X)
    return torch.max(X, a)
    
@d2l.add_to_class(MLPScratch)
def forward(self, X):
    X = X.reshape((-1, self.num_inputs))
    H = relu(torch.matmul(X, self.W1) + self.b1)
    return torch.matmul(H, self.W2) + self.b2

model = MLPScratch(num_inputs=784, num_outputs=10, num_hiddens=256, lr=0.1)
data = d2l.FashionMNIST(batch_size=256)
trainer = d2l.Trainer(max_epochs=10)
trainer.fit(model, data)
```

如果使用高级 API 实现，代码会更加简洁。

```c
class MLP(d2l.Classifier):
    def __init__(self, num_outputs, num_hiddens, lr):
        super().__init__()
        self.save_hyperparameters()
        self.net = nn.Sequential(nn.Flatten(), nn.LazyLinear(num_hiddens),
                                 nn.ReLU(), nn.LazyLinear(num_outputs))
```





<h3 id="uILA8">transformer</h3>
李宏毅讲解的 transformer[Transformer - YouTube](https://www.youtube.com/watch?v=ugWDIIOHtPA&list=PLJV_el3uVTsOK_ZK5L0Iv_EQoL1JefRL4&index=61)



<h3 id="Bid2b">强化学习</h3>
强化学习主要用于解决顺序决策问题，并且与环境有很强的交互；强化学习和标准的深度学习最大的不同是强化学习在未来时刻做的决策会受到过去决策的影响；

<h4 id="DIxvF">MDP</h4>
马尔可夫决策过程的公式：![image](https://cdn.nlark.com/yuque/__latex/752392b30285cd6303f42a1fc6982faa.svg)，由状态、动作、状态转移函数和奖励组成。

马尔可夫决策过程的重点在于下一个状态不依赖于过去采取了那些动作，即具有独立性。

<h4 id="b2xo7">值迭代</h4>
**值函数**：由两部分组成，第一个是在当前状态执行某个动作的即时奖励，第二部分是采取该动作后转移到下一个状态 s1 的平均奖励。

![image](https://cdn.nlark.com/yuque/__latex/a82ca505d220b49ba1afe2b2db400a31.svg)

动作值函数：也是由两部分组成，不过第二部分不是值函数，而是动作值函数，即采取该动作后转移到下一个状态，并对该状态下所有的动作值函数求期望来计算奖励函数。

![image](https://cdn.nlark.com/yuque/__latex/5f75d26a3bc4b3b36ebb3f30b1a3ab1a.svg)

最优策略就是在每一步都选择使得奖励最大的动作使得总奖励函数最大。

<h4 id="wroAf">Q-learning</h4>
在值函数迭代中需要知道不同状态转移的概率，因为需要对所有的 MDP 过程的奖励函数求期望，但是状态转移有时候很难获得，很难对环境进行建模。而 Q-learning 可以实现值函数的近似，并且不需要状态转移概率。

通过使用另外一个策略收集的数据来实现值函数迭代的近似版本,下式是 Q-learning 的优化问题,通过最小化该动作值函数和最优策略下的动作值函数,来实现该动作值函数是最优策略的动作值函数.其中没有涉及到状态转移概率![image](https://cdn.nlark.com/yuque/__latex/ada351d09ae3df4bf8daaa2b1e51f432.svg)是因为最优策略是一个确定性的策略,在每一步选择的动作概率都是 1.

![image](https://cdn.nlark.com/yuque/__latex/29dcf57cb63d4ead8b41982a3b2d8fbe.svg)

Q-learning 将根据策略与环境交互得到的轨迹去计算值函数迭代，下式是 Q-learning 的优化函数，其中没有将状态转移概率![image](https://cdn.nlark.com/yuque/__latex/ada351d09ae3df4bf8daaa2b1e51f432.svg)显示在优化函数目标中，而是通过对采集的轨迹数据进行采样，来计算在当前状态执行某动作之后，转移到下一个状态的概率。

![image](https://cdn.nlark.com/yuque/__latex/36f47be647c444e11e10c90335ed5174.svg)

其中![image](https://cdn.nlark.com/yuque/__latex/6b48c0c71a1d3cedd598586ec2eda3ab.svg)如果状态时终止状态时为 1,其它状态下为 0.

由于是利用之前收集的数据去进行优化,那么收集数据使用的策略很重要,如果收集的数据不能包含所有的动作状态,那么最后优化的动作值函数效果肯定会很差.所以为了避免这种状况,使用探索因子来保证策略具有随机性,并能访问所有的状态.

![image](https://cdn.nlark.com/yuque/__latex/d7a66f150dd445b156b2677af4eedcf0.svg)

其中![image](https://cdn.nlark.com/yuque/__latex/7c102e7a7d231bf935f9bc23417779a8.svg)为探索因子,表示当前的策略以这个概率去进行探索.

在实际的 Q-learning 实践过程中,一般都会在策略执行某个动作之后,利用收集到的数据,采用其中的一小批 对策略进行更新来保证动作值函数的最优估计值.

<h3 id="Mqqos">生成对抗网络</h3>
机器学习一般用来进行预测，即训练从数据示例到标签学习的映射，但是还有一种应用是用于生成和给定数据集分布类似的数据。而 2014 年提出的生成对抗网络 GANs 就是利用判别模型来获得较好的生成模型的新方法，GANs 的核心包括训练一个鉴别器来判别生成的数据和给定数据之间是不是同一个分布，还有重要的一点是使用这两个样本去训练生成器，直到生成器可以生成类似的真实数据。

![](https://cdn.nlark.com/yuque/0/2024/svg/39264174/1724136562264-18cc3818-5394-42a3-ac42-a15b07ce5f01.svg)

生成对抗网络

GAN 由两部分组成，首先需要一个设备来生成数据，这个设备可以是一个网络生成图像或者一个渲染引擎生成动作或者生成语音等等，总之称之为生成器网络；还有一个是鉴别器网络，试图区虚假的数据还是真实的数据，这两个网络相互学习，相互竞争。

鉴别器是一个二元分类器，用于区分输入的 x 是真是的还是假的，鉴别器的输出层使用全连接层，然后使用 sigmoid 激活函数，训练鉴别器来最小化交叉熵损失函数：

![image](https://cdn.nlark.com/yuque/__latex/e90e0db11ede1623c7f6009fe36c83fe.svg)

生成器通常的输入是一个随机分布，比如正态分布，输入的变量 z 通常叫做潜在变量，然后输入到一个生成函数中![image](https://cdn.nlark.com/yuque/__latex/22167279cccaf7ced2f66af54ad66e5e.svg)，这个函数可以用一个网络去拟合，生成器的目标是生成的数据欺骗鉴别器，使鉴别器将生成器生成的数据判别为真实数据![image](https://cdn.nlark.com/yuque/__latex/1e5f7197dfd080dbf2569592ec0dd518.svg)，对于给定的判别器 D，生成器的目标函数是最大化交叉熵损失函数

![image](https://cdn.nlark.com/yuque/__latex/ec7e7a87eeed1c1acde7f6c65d5e13a7.svg)，如果生成器生成的数据足够真实，那么![image](https://cdn.nlark.com/yuque/__latex/4b396ed6b653ef174a27a6f1fd7029df.svg)，即损失函数接近于 0，会导致梯度太小无法更新判别器，因此通常使用以下损失函数，通过最小化 G 实现：

![image](https://cdn.nlark.com/yuque/__latex/7373509449a779df5434193ce1600820.svg)

综上：生成器和辨别器通过相互对抗、相互学习，训练鉴别器和生成器：

![image](https://cdn.nlark.com/yuque/__latex/a8190db29af3d7e843489c04d92fcbe9.svg)

**总结**

+ 生成对抗网络由两个深度网络组成：生成器和鉴别器；
+ 生成器生成的数据需要尽可能接近真实图像，通过最大化交叉熵损失函数实现欺骗鉴别器![image](https://cdn.nlark.com/yuque/__latex/8f4af56b7dcd8588d36d86285d8fae55.svg)
+ 鉴别器需要尽可能区分生成的数据和真实的数据，通过最小化交叉熵损失函数![image](https://cdn.nlark.com/yuque/__latex/32bc8780bb7bf43087c1c935a69f10e0.svg)

<h1 id="VC7CX">多刚体动力学</h1>


